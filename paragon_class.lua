---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ithorgrim.
--- DateTime: 17/03/2022 11:04
---
---
local Object = require("rxi_classic")

local Paragon = require("paragon")
      Paragon.Class = Object:extend()

      Paragon.ServerInformations = {
            quest_informations = {},
            creature_informations = {},
            gossip_informations = {},
            spells_informations = {}
      }

--[[

    Technical Function

]]--

local function GTP_Gossip()
    Paragon.ServerInformations.gossip_informations = {}

    local GetGossip = WorldDBQuery("SELECT * FROM "..Paragon.Config.Database..".paragon_gossip_menu")
    if (not GetGossip) then
        return false
    end

    repeat
        Paragon.ServerInformations.gossip_informations[ #Paragon.ServerInformations.gossip_informations +1 ] = {
            menu_id = GetGossip:GetUInt32(0),
            option_menu_id = GetGossip:GetUInt32(1),
            option_text = GetGossip:GetString(2),
            action_type = GetGossip:GetUInt32(3),
            action_id = GetGossip:GetUInt32(4),
            cond_class_id = GetGossip:GetUInt32(5)
        }
    until not GetGossip:NextRow()
end

local function GTP_Creature()
    Paragon.ServerInformations.creature_informations = {}

    local GetCreature = WorldDBQuery("SELECT * FROM "..Paragon.Config.Database..".paragon_creature")
    if (not GetCreature) then
        return false
    end

    repeat
        local cId, cExp = GetCreature:GetUInt32(0), GetCreature:GetUInt32(1)

        if (not cExp or cExp < 0) then
            cExp = Paragon.Config.UniversaleCreatureExp
        end

        Paragon.ServerInformations.creature_informations[cId] = cExp
    until not GetCreature:NextRow()
end

local function GTP_Quest()
    Paragon.ServerInformations.quest_informations = {}

    local GetQuest = WorldDBQuery("SELECT * FROM "..Paragon.Config.Database..".paragon_quest")
    if (not GetQuest) then
        return false
    end

    repeat
        local qId, qExp = GetQuest:GetUInt32(0), GetQuest:GetUInt32(1)

        if (not qExp or qExp < 0) then
            qExp = Paragon.Config.UniversaleQuestExp
        end

        Paragon.ServerInformations.quest_informations[qId] = qExp
    until not GetQuest:NextRow()
end

local function GTP_Spell()
    Paragon.ServerInformations.spells_informations = {}

    local GetSpell = WorldDBQuery("SELECT * FROM "..Paragon.Config.Database..".paragon_spell")
    if (not GetSpell) then
        return false
    end

    repeat
        local sId, sName, sMinVal, sMaxVal = GetSpell:GetUInt32(0), GetSpell:GetString(1), GetSpell:GetUInt32(2), GetSpell:GetUInt32(3)
        if (not sName) then sName = tostring(sId) end
        if (not sMaxVal or sMaxVal > 255 or sMaxVal < 0) then sMaxVal = 255 end
        if (not sMinVal or sMinVal > 255 or sMinVal < 0) then sMinVal = 0 end
        if (not sMaxVal or sMaxVal > 255 or sMaxVal < 0 or sMaxVal > Paragon.Config.MaxSpellPoints) then sMaxVal = 255 end

        Paragon.ServerInformations.spells_informations[sId] = { spellname = sName, minval = sMinVal, maxval = sMaxVal }
    until not GetSpell:NextRow()
end

local function GTP_GetInformations(event)
    GTP_Spell()

    if (Paragon.Config.QuestGiveExp) then GTP_Quest() end
    if (Paragon.Config.CreatureGiveExp) then GTP_Creature() end
    if (Paragon.Config.Type == 1 or Paragon.Config.Type == 3) then GTP_Gossip() end
end
RegisterServerEvent(33, GTP_GetInformations)

--[[

    Paragon Class

]]--

function Paragon.Class:new()
    self.status = true
    self.spells = {}

    for spellId, data in pairs(Paragon.ServerInformations.spells_informations) do
        if (not self.spells[spellId]) then
            self.spells[spellId] = { points = data.minval, spell = data.spellname }
        end
    end

    self.informations = {
        level = 1,
        exp = 0,
        max_exp = 500
    }

    self.points = 0
end

function Paragon.Class:Method(method)
    local switch = {
        [0] = function() return self:GetLevel() end,
        [2] = function() return self:ResetSpells() end,
        [3] = function() return self:GetPoints() end,
        [4] = function() return self:Disable() end,
        [5] = function() return self:Enable() end
    }

    return switch[method]() or false
end

function Paragon.Class:SetSpellPoint(spell, points, add)
    local sPoints = 0

    if (not add) then
        if (points > self.spells[spell].points) then
            return false
        end

        if (self.spells[spell].points == Paragon.ServerInformations.spells_informations[spell].minval) then
            return false
        end
    else
        if (self:GetPoints() < points) then
            return false
        end
    end

    sPoints = self.spells[spell].points + points
    if (sPoints <= 0) then
        return false
    end

    if (sPoints > Paragon.Config.MaxSpellPoints) then
        return false
    end

    self.spells[spell].points = sPoints
    self:SetPoints()
    return true
end

function Paragon.Class:SetLevel()
    self.informations.exp = 0

    self.informations.level = self.informations.level + 1
    self.informations.max_exp = self.informations.max_exp * self.informations.level

    self:SetPoints()
    return true
end

function Paragon.Class:GetLevel()
    return self.informations.level
end

function Paragon.Class:ExpCalc()
    if (self.informations.exp >= self.informations.max_exp) then
        self:SetLevel()
        self:SetExp(self.informations.exp - self.informations.max_exp)
        return true
    end
end

function Paragon.Class:SetExp(value)
    self.informations.exp = self.informations.exp + value
    return self:ExpCalc()
end

function Paragon.Class:SetPoints()
    self.points = self:GetPoints()
end

function Paragon.Class:ResetSpells()
    for spellId, data in pairs(Paragon.ServerInformations.spells_informations) do
        self.spells[spellId] = { points = data.minval, spell = data.spellname }
    end
end

function Paragon.Class:GetPoints()
    local tPoints = self.informations.level * Paragon.Config.PointPerLevel
    local pPoints = 0

    for spell, spell_informations in pairs(self.spells) do
        pPoints = pPoints + (spell_informations.points - Paragon.ServerInformations.spells_informations[spell].minval)
    end

    if (pPoints > tPoints) then
        self:ResetSpells()
    else
        tPoints = tPoints - pPoints
    end

    return tPoints
end

function Paragon.Class:Disable()
    if (not self.status) then
        return false
    end

    self.Status = false
end

function Paragon.Class:Enable()
    if (self.status) then
        return false
    end

    self.Status = true
end

--[[

    Player Class Override

]]--

function Player:SetParagon()
    local pGuid = self:GetGUIDLow()
    local pAccid = self:GetAccountId()
    local paragon = Paragon.Class()

    local GetParagonData = CharDBQuery( "SELECT * FROM "..Paragon.Config.Database..".paragon_character WHERE guid = " ..pGuid)

    if (not GetParagonData) then
        print("This player doesn't have a Paragon Information registered :\nID -> "..pAccid.." GUID -> "..pGuid)
    else
        repeat
            local spell_id, spell_points = GetParagonData:GetUInt32(1), GetParagonData:GetUInt32(2)

            for var, data in pairs(Paragon.ServerInformations.spells_informations) do
                if (data.spellid == spell_id) then
                    paragon[spell_id].points = spell_points
                end
            end
        until not GetParagonData:NextRow()
    end

    self:SetData("paragon", paragon)
end

function Player:SetAllParagonAura()
    local paragon = self:GetData("paragon")

    for spell_id, _ in pairs(paragon.spells) do
        self:SetParagonAura(spell_id)
    end
end

function Player:SetParagonAura(spell_id)
    local paragon = self:GetData('paragon')

    if (not paragon.status) then
        return false
    end

    local pAura = self:GetAura( spell_id )
    if ( not pAura ) then
        self:AddAura( spell_id, self )
    end

    self:GetAura( spell_id ):SetStackAmount( paragon.spells[spell_id].points )
end
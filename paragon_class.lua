---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by ithorgrim.
--- DateTime: 17/03/2022 11:04
---
---
local Object = require("rxi_classic")

local Paragon = require("paragon")
Paragon.Class = Object:extend()

Paragon.ServerInformations = {
    quest_informations = {},
    creature_informations = {},
    gossip_informations = {},
    spells_informations = {},

    locale_informations = {}
}

--[[

    Technical Function

]]--

local function GTP_Locale()
    Paragon.ServerInformations.locale_informations = {}

    local GetLocale = WorldDBQuery("SELECT * FROM "..Paragon.Config.Database..".paragon_locale")
    if (not GetLocale) then
        return false
    end

    repeat
        if ( not Paragon.ServerInformations.locale_informations[ GetLocale:GetString(1) ] ) then
            Paragon.ServerInformations.locale_informations[ GetLocale:GetString(1) ] = { }
        end

        Paragon.ServerInformations.locale_informations[ GetLocale:GetString(1) ][ GetLocale:GetUInt32(0) ] = GetLocale:GetString(2)
    until not GetLocale:NextRow()

    return true
end

local function GTP_Gossip()
    Paragon.ServerInformations.gossip_informations = {}

    local GetGossip = WorldDBQuery("SELECT * FROM "..Paragon.Config.Database..".paragon_gossip_menu")
    if (not GetGossip) then
        return false
    end

    repeat
        Paragon.ServerInformations.gossip_informations[ #Paragon.ServerInformations.gossip_informations + 1 ] = {
            menu_id = GetGossip:GetUInt32(0),
            option_menu_id = GetGossip:GetUInt32(1),
            option_text = GetGossip:GetString(2),
            action_type = GetGossip:GetUInt32(3),
            action_id = GetGossip:GetUInt32(4),
            cond_class_id = GetGossip:GetUInt32(5)
        }
    until not GetGossip:NextRow()
    return true
end

local function GTP_Creature()
    Paragon.ServerInformations.creature_informations = {}

    local GetCreature = WorldDBQuery("SELECT * FROM "..Paragon.Config.Database..".paragon_creature")
    if (not GetCreature) then
        return false
    end

    repeat
        local creature_id, creature_exp = GetCreature:GetUInt32(0), GetCreature:GetUInt32(1)

        if (not creature_exp or creature_exp < 0) then
            creature_exp = Paragon.Config.UniversaleCreatureExp
        end

        Paragon.ServerInformations.creature_informations[creature_id] = creature_exp
    until not GetCreature:NextRow()
    return true
end

local function GTP_Quest()
    Paragon.ServerInformations.quest_informations = {}

    local GetQuest = WorldDBQuery("SELECT * FROM "..Paragon.Config.Database..".paragon_quest")
    if (not GetQuest) then
        return false
    end

    repeat
        local quest_id, quest_exp = GetQuest:GetUInt32(0), GetQuest:GetUInt32(1)

        if (not quest_exp or quest_exp < 0) then
            quest_exp = Paragon.Config.UniversaleQuestExp
        end

        Paragon.ServerInformations.quest_informations[quest_id] = quest_exp
    until not GetQuest:NextRow()
    return true
end

local function GTP_Spell()
    Paragon.ServerInformations.spells_informations = {}

    local GetSpell = WorldDBQuery("SELECT * FROM "..Paragon.Config.Database..".paragon_spell")
    if (not GetSpell) then
        return false
    end

    repeat
        local spell_id, spell_name, spell_minval, spell_maxval = GetSpell:GetUInt32(0), GetSpell:GetString(1), GetSpell:GetUInt32(2), GetSpell:GetUInt32(3)
        if (not spell_name) then spell_name = tostring(spell_id) end
        if (not spell_minval or spell_minval > 255 or spell_minval < 0) then spell_minval = 0 end
        if (not spell_maxval or spell_maxval > 255 or spell_maxval < 0 or spell_maxval > Paragon.Config.MaxSpellPoints) then spell_maxval = Paragon.Config.MaxSpellPoints end

        Paragon.ServerInformations.spells_informations[spell_id] = { spellname = spell_name, minval = spell_minval, maxval = spell_maxval }
    until not GetSpell:NextRow()
    return true
end

local function GTP_GetInformations(event)
    GTP_Locale()
    GTP_Spell()

    if (Paragon.Config.QuestGiveExp) then GTP_Quest() end
    if (Paragon.Config.CreatureGiveExp) then GTP_Creature() end
    if (Paragon.Config.Type == 1 or Paragon.Config.Type == 3) then GTP_Gossip() end
end
RegisterServerEvent(33, GTP_GetInformations)

--[[

    Paragon Class

]]--

function Paragon.Class:new()
    self.status = true
    self.spells = {}

    for spellId, data in pairs(Paragon.ServerInformations.spells_informations) do
        if (not self.spells[spellId]) then
            self.spells[spellId] = { points = data.minval, spell = data.spellname }
        end
    end

    self.informations = {
        level = 1,
        exp = 0,
        max_exp = 500
    }

    self.points = self:GetPoints()
end

function Paragon.Class:Method(method, player)
    local switch = {
        [0] = function() self:GetLevel() end,
        [1] = function() self:ResetSpells() player:SetAllParagonAura() end,
        [2] = function() self:GetPoints() end,
        [3] = function() self:Disable() end,
        [4] = function() self:Enable() end,
    }

    return switch[method]() or false
end

function Paragon.Class:SetSpellPoint(spell, points, add)
    local points_awarded = 0

    if (not add) then
        if (points > self.spells[spell].points) then
            return false
        end

        if (self.spells[spell].points == Paragon.ServerInformations.spells_informations[spell].minval) then
            return false
        end

        if (self.spells[spell].points + points < Paragon.ServerInformations.spells_informations[spell].minval) then
            return false
        end
    else
        if (self:GetPoints() < points) then
            return false
        end
    end

    points_awarded = self.spells[spell].points + points
    if (points_awarded < 0) then
        return false
    end

    if (points_awarded > Paragon.Config.MaxSpellPoints) then
        return false
    end

    self.spells[spell].points = points_awarded
    self:SetPoints()

    return true
end

function Paragon.Class:SetLevel()
    self.informations.exp = 0

    self.informations.level = self.informations.level + 1
    self.informations.max_exp = Paragon.Config.UniversaleQuestExp * self.informations.level

    self:SetPoints()
    return true
end

function Paragon.Class:GetLevel()
    return self.informations.level
end

function Paragon.Class:ExpCalc()
    if (self.informations.exp >= self.informations.max_exp) then
        local new_exp = self.informations.exp - self.informations.max_exp
        self:SetLevel()
        self:SetExp(new_exp)
        return true
    end
end

function Paragon.Class:SetExp(value)
    self.informations.exp = self.informations.exp + value
    return self:ExpCalc()
end

function Paragon.Class:SetPoints()
    self.points = self:GetPoints()
end

function Paragon.Class:ResetSpells()
    for spellId, data in pairs(Paragon.ServerInformations.spells_informations) do
        self.spells[spellId] = { points = data.minval, spell = data.spellname }
    end
    self:SetPoints()
end

function Paragon.Class:GetPoints()
    local total_points = self.informations.level * Paragon.Config.PointPerLevel
    local points_awarded = 0

    for spell, spell_informations in pairs(self.spells) do
        points_awarded = points_awarded + (spell_informations.points - Paragon.ServerInformations.spells_informations[spell].minval)
    end

    if (points_awarded > total_points) then
        self:ResetSpells()
    else
        total_points = total_points - points_awarded
    end

    return total_points
end

function Paragon.Class:Disable()
    if (not self.status) then
        return false
    end

    self.Status = false
    return true
end

function Paragon.Class:Enable()
    if (self.status) then
        return false
    end

    self.Status = true
    return true
end

--[[

    Player Class Override

]]--

function Player:SetParagon()
    local pGuid = self:GetGUIDLow()
    local pAccid = self:GetAccountId()
    local paragon = Paragon.Class()

    local GetCharacterParagon = CharDBQuery( "SELECT * FROM "..Paragon.Config.Database..".paragon_character WHERE guid = " ..pGuid)

    if (GetCharacterParagon) then
        repeat
            local spell_id, spell_points = GetCharacterParagon:GetUInt32(1), GetCharacterParagon:GetUInt32(2)

            for var, data in pairs(Paragon.ServerInformations.spells_informations) do
                if (data.spellid == spell_id) then
                    paragon[spell_id].points = spell_points
                end
            end
        until not GetCharacterParagon:NextRow()
    end

    self:SetData("paragon", paragon)
end

function Player:SetAllParagonAura()
    local paragon = self:GetData("paragon")

    for spell_id, _ in pairs(paragon.spells) do
        self:RemoveAura(spell_id)
        self:SetParagonAura(spell_id)
    end
end

function Player:SetParagonAura(spell_id)
    local paragon = self:GetData('paragon')

    if (not paragon.status) then
        return false
    end

    local pAura = self:GetAura( spell_id )
    if ( not pAura ) then
        self:AddAura( spell_id, self )
    end

    self:GetAura( spell_id ):SetStackAmount( paragon.spells[spell_id].points )
    return true
end